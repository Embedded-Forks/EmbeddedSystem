# 软件架构设计

- 一个好的架构，不仅要在某一特定时刻满足软件用户、开发者和所有者的需求，更要在一段时间内持续满足他们的后续需求。
- 软件架构没有固定的展现形式，每一个视图都是架构师所做的层层抉择。
- 所谓软件架构，就是你希望在项目一开始就能做对，但是却不一定能够做得对的决策的集合。
- 软件架构规则和其他变量完全无关。
- 底层设计细节和高层架构信息是不可分割的，他们组合在一起，共同定义了整个软件系统，缺一不可。所谓底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。
- 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。（所以考虑维护成本是很重要的）
- 要想跑得快，先要跑的稳。
- 软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。
- 结构化编程赋予了我们创造可证伪程序单元的能力，这就是为什么现代编程语言一般不支持无限制的 `goto` 语句。因此在架构设计领域，功能性讲解拆分仍然是最佳实践之一。

## 整洁的嵌入式架构

### 编写软件而不是编写固件

虽然软件本身并不会随着时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动。其中软件（software）应该是一种使用周期很长的东西，而固件（firmware）则会随着硬件演进而淘汰过时。

固件不是依据其存储的位置来定义的，而是由其代码的依赖关系，及其随着硬件的演进在变更难度上的变化来定义的。硬件的演进是显而易见的，我们在架构嵌入式代码时要时刻记住这一点。

要时刻记住 **编写软件而不是编写固件。**

### 程序适用性测试

为什么这么多嵌入式软件最后都成了固件？看起来，很可能是因为我们在做嵌入式设计时只关注代码能否顺利运行，并不太关心其结构能否撑起一个较长的有效生命周期。Kent Beck 描述了软件构建过程中的三个阶段：

1. “先让代码工作起来”——如果代码不能工作，就不能产生价值。
2. “然后再试图将它变好——通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。
3. “最后再试着让它运行得更快”——按照性能提升的“需求”来重构代码。

对于程序员来说，让他的程序工作这件事只能被称为“程序适用测试（app-titude test）”。一个程序员，不论他写的是否是嵌入式程序，如果目标仅仅是让程序可以工作，恐怕对他的老板和这个程序本身而言都是一件坏事。毕竟，编程这件事可远不止是让程序可以工作这么简单。

代码能够正确工作，只是对程序最基本的要求，并不能说该应用程序有一套整洁的嵌入式结构。

## 目标硬件瓶颈

### 整洁的嵌入式架构就是可测试的嵌入式架构

### Layers 分层

### 硬件是实现细节

### 不要向 HAL 的用户暴露硬件细节

依照整洁的嵌入式架构所构建的软件应该是可以脱离目标硬件平台来进行测试的。因为设计合理的 HAL 可以为我们脱离硬件平台的测试提供相应的支撑。

### 处理器是实现细节

### 操作系统是实现细节

### 面向接口编程与可替代性

除了在嵌入式系统的主要分层（指软件、操作系统、固件、硬件这四层）之中增加 HAL 和 OSAL 之外，我们还可以——也应该——应用本书中提到的其他设计原则。这些设计原则可以帮助我们按功能模块、接口编程以及可替代性来划分系统。

分层架构的理念是基于接口编程的理念来设计的。当模块之间能以接口形式交互时，我们就可以将一个服务替换成另外一个服务。例如，很多读者应该都写过能在某个目标机器上运行的、小型的自定义的 `printf` 函数。只要我们的 `printf` 与标准的 `printf` 函数接口一致，它们就可以互相替换。

目前的普适规则之一就是用头丈件来充当接口的定义。然而，如果真的要这样做的话，就需要小心控制头文件中的内容，尽量确保头文件中只包括函数声明，以及函数所需要的结构体名字和常量。

另外，不要在定义接口的头文件中包含只有具体实现代码才需要的数据结构、常量以及类型定义（typedef）。这不仅仅是架构是否整洁的问题，而是这样做可能会导致意外的依赖关系。总之，我们必须控制好实现细节的可见性，因为这些实现细节是肯定会变化的。关注实现细节的代码越少，它们所需的变更就越少。

由整洁的嵌入式架构所构建的系统应该在每一个分层中都是可测试的，因为它的模块之间采用接口通信，每一个接口都为平台之外的测试提供了替换点。

### 条件性编译命令

另一个经常被忽视的可替代换性规则的实际案例是嵌入式 C/C++ 程序对不同平台和操作系统的处理方式。这些程序经常会用条件性编译命令来根据不同的平台启用和禁用某一段代码。例如，我曾经遇到过 `#ifdef BOARD_V2` 这条语句在一个电信应用程序中出现了几千次的情况。

很显然，这种代码的重复违背了“不要重复自己（DRY）”原则。如果 `#ifdef BOARD_V2` 只出现一次，这当然不是什么问题，而如果出现了 6000 次，那就非常严重了。但这类条件性编译语句在嵌入式编程中非常常见，有什么好的解决方案吗？

使用硬件抽象层如何？这样的话，硬件类型就只是 HAL 中的一个实现细节了。而且，如果系统中使用的是 HAL 所提供的一系列接口，而不是条件性编译语句，那么我们就可以用链接器，或者某种运行时加载器来将软件与硬件相结合了。

### 总结

嵌入式编程人员应该多学习一些非嵌入式系统的编程经验。

为了让我们的产品能长期地保持健康，请别让你的代码都变成固件。如果一个系统的代码只能在目标硬件上测试，那么它的开发过程会变得非常艰难。总之，为产品的长期健康着想而采用一套整洁的嵌入式架构是很有必要的。

## 面向对象开发

### 面向对象分析（OOA）

先从最简单的方案想起，然后再优化。把整个分析的过程分为 4 轮，每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具体化，最终产生清晰的、可落地的需求定义。

需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以一定不要只关心设计与实现，前期的需求分析同等重要。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

### 面向对象设计（OOD）

### 面向对象编程（OOP）

## 软件设计原则

### 单一职责原则

### OCP 开闭原则

### 里氏替换原则

### 接口隔离原则

### 依赖反转原则

控制反转、依赖反转、依赖注入。

### KISS、YAGNI 原则

### 如何提高代码复用性

- 减少代码耦合

  - 对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为

    一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵

    连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少

    代码耦合。

- 满足单一职责原则

  - 我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的

    代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相

    反，越细粒度的代码，代码的通用性会越好，越容易被复用。

- 模块化

  - 这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将

    功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接

    拿来搭建更加复杂的系统。

- 业务与非业务逻辑分离

  - 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用

    跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组

    件等。

- 通用代码下沉

  - 从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复

    用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层

    代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码

    我们尽量下沉到更下层。

- 继承、多态、抽象、封装

  - 在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用

    父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复

    用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的

    话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露

    不变的接口，就越容易复用。

- 应用模板等设计模式

  - 一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替

    换其中的部分代码，整个流程模板代码可复用。

除了上面的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。

### 高内聚、松耦合

Law of Demeter 缩写是 LOD，还有一个更加达意的名字叫做最小知识原则，英文翻译为 The Least Knowledge Principle。

```
Each unit should have only limited knowledge about other units: only units
“closely” related to the current unit. Or: Each unit should only talk to its
friends; Don’t talk to strangers.
```

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的有限知识）。

依赖的接口越多，那么当接口的实现有变动时，就需要执行更多的测试工作量。

- 如何理解高内聚、低耦合？

  - “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，

    缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指

    导类与类之间依赖关系的设计。

  - 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相

    近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代

    码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会

    或者很少导致依赖类的代码改动。

- 如何理解迪米特法则

  - 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接

    口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其

    他部分。一旦发生变化，需要了解这一变化的类就会比较少。

## 

## Code Review

### 关注点

- 代码结构是否合理?
- 代码是否容易理解？
- 业务是否正确?
- 异常考虑是否全面？
- 是否有隐藏的 bug?
- 线程是否安全？
- 性能是否满足业务需求？
- 是否符合编码规范？

### Google review 最佳实践

https://jimmysong.io/eng-practices/docs/review/reviewer/standard/

在进行代码审查时，您应该确保：

- 代码设计精良。
- 该功能对代码用户是有好处的。
- 任何 UI 变更都是合理的且看起来是好的。
- 其中任何并行编程都是安全的。
- 代码并不比它需要的复杂。
- 开发人员没有实现他们将来**可能**需要，但不知道他们现在是否需要的东西。
- 代码有适当的单元测试。
- 测试精心设计。
- 开发人员使用了清晰的名称。
- 注释清晰有用，且大多用来解释**为什么**而不是**做什么**。
- 代码有适当记录成文件（通常在 g3doc 中）。
- 代码符合我们的风格指南。

确保查看您被要求查看的**每一行**代码，查看**上下文**，确保您**提高代码健康状况**，并赞扬开发人员所做的**好事**。
