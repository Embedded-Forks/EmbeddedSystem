# 软件设计思想与原则

## 单一职责原则

## OCP 开闭原则

## 里氏替换原则

## 接口隔离原则

## 依赖反转原则

控制反转、依赖反转、依赖注入。

## KISS、YAGNI 原则

## 如何提高代码复用性

- 减少代码耦合

  - 对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。

- 满足单一职责原则

  - 我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。

- 模块化

  - 这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。

- 业务与非业务逻辑分离

  - 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。

- 通用代码下沉

  - 从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。

- 继承、多态、抽象、封装

  - 在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。

- 应用模板等设计模式

  - 一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。


除了上面的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。

## 高内聚、松耦合

Law of Demeter 缩写是 LOD，还有一个更加达意的名字叫做最小知识原则，英文翻译为 The Least Knowledge Principle。

```
Each unit should have only limited knowledge about other units: only units
“closely” related to the current unit. Or: Each unit should only talk to its
friends; Don’t talk to strangers.
```

1. 不该有直接依赖关系的类之间，不要有依赖
2. 有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的有限知识）
3. 基于最小接口而非最大实现编程

依赖的接口越多，那么当接口的实现有变动时，就需要执行更多的测试工作量。

- 如何理解高内聚、低耦合？

  - “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。

  - 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

- 如何理解迪米特法则

  - 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

# 业务系统分析与设计

要有能力独立负责一个系统，能端到端开发一个完整的系统，这其中的工作就包括，前期的需求沟通分析，中期的代码设计实现，后期的系统上线维护等。

## 需求分析

通过一些工具收集需求，罗列用户用例。

## 系统设计

面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块）两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。

### 合理地将功能划分到不同模块

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

### 模块间的交互关系

常见的系统之间的交互关系有两种：

- 一种是同步接口调用
- 另一种是利用消息中间件异步调用

第一种方式简单直接，第二种方式的解耦效果更好。上下层系统之间的调用倾向于通过 同步接口，同层之间的调用倾向于异步消息调用。

## 模块的接口、数据库、业务模型

业务系统本身的设计无外乎有这样三方面的工作要做：

- 接口设计
- 数据库设计
- 业务模型设计（也就是业务逻辑）

### 数据库

主要设计事务表（每次操作时产生的数据）的内容，一些总体的信息可以通过统计计算这些表的内容来得到。

### 接口设计

接口设计要符合单一职责原则，粒度越小通用性就越好。但是接口粒度太小也会带来一些问题，一个功能的实现需要调用多个小接口

- 如果接口走网络，多次调用会影响性能
- 本该在一个接口中完成的原子操作，现在拆分成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，另一个接口执行失败了）

所以为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，在封装一层粗粒度的接口给外部使用。

### 业务模型

从代码实现的角度来说，大部分业务系统的开发都可以分为 controller、service、repository 三层。

- controller 层负责接口暴露
- repository 层负责数据读写
- service 层负责核心业务逻辑，也就是这里的业务模型

## 为什么需要 MVC 三层开发

- 分层能起到代码复用的作用
  - 同一个 repository 可能会被多个 service 调用
  - 同一个 service 可能会被多个 controller 调用
  - 如果没有 service 层，每个 controller 可能需要实现同样的逻辑，违背 DRY 原则
- 分层能起到隔离变化的作用
  - 分层体现了抽象和封装的设计思想。比如 repo 实现了对数据库访问的操作，提供了抽象的数据访问接口。
  - 基于接口而非实现编程的设计思想，service 层使用 repo 层提供的接口，并不关心底层依赖的是那种具体的数据库，便于替换数据库。
  - controller service repository 三层的稳定程度不同，分层之后，controller 层的变化不会影响到稳定的的 repository 层。
- 分层能起到隔离关注点的作用
  - repository 层只关注数据的读写
  - service 层只关注业务逻辑，不关心数据来源
  - controller 层只关注与外界打交道，数据校验、封装、格式转换，不关心业务
  - 三层之间的关注点不同，分层之后，职责分明，更加符合单一原则，代码的内聚性更好
- 分层能提高代码的可测试性
  - 下层的代码通过依赖注入的方式供上层使用
  - 可以用 mock 的数据来替代真实数据
- 分层能应对系统的复杂性
  - 当一个类或者一个函数的代码过多之后，可读性、可维护性就会变差，那就要想办法拆分，拆分分为垂直和水平两个方向：
    - 水平方向基于业务来做拆分，就是模块化
    - 竖直方向基于流程来做拆分，就是这里说的分层
  - 不管是分层、模块化，还是 OOP、DDD、以及各种设计模式，原则和思想，都是为了应对复杂系统，应对系统的复杂性，对于简单系统是发挥不了作用的。

## 设计模型与思想

![image-20240314114017391](figures/image-20240314114017391.png)

# 通用框架分析与设计

## 需求分析

### 功能性需求分析

### 非功能性需求分析

## 框架设计

基于最小原型的思想，先聚集一个简单的场景，基于此设计实现一个简单的原型。
