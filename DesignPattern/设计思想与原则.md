# 软件设计思想与原则

## 单一职责原则

## OCP 开闭原则

### 实践思考

一个软件模块实现了很多通用逻辑，如果想添加一些特殊处理进去而不想修改软件模块，可以考虑给这个模块添加拓展点，让其他模块注册更多处理逻辑到该模块中。这样增加功能时就不需要修改原有代码。

## 里氏替换原则

## 接口隔离原则

对于接口隔离原则的重点是理解接口的意义，这里有三种不同的理解：

如果把接口理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。

如果把接口理解为单个 API 接口或者函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖他需要的那个细粒度函数。

如果把接口理解成 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用类，依赖不需要的接口函数。

### 实践思考

有些时候一个头文件中暴露出了过多的接口，如果某个调用者只依赖部分接口，那么可以针对该调用者提供暴露功能更少的头文件。

在 C 语言中，如果调用者拿到了一个对象的结构体，那么它就有能力直接访问该对象的所有成员变量，但是有些时候我们并不希望调用者有能力访问对象部分属性。这时候我们可以只向调用者提供对象结构体的某些成员变量类型，然后实现一组必要的 SET/GET 函数，让调用者使用这一组有限的接口修改对象的属性。

## 依赖反转原则

控制反转、依赖反转、依赖注入。

## KISS、YAGNI 原则

## 迪米特法则

Law of Demeter 缩写是 LOD，还有一个更加达意的名字叫做最小知识原则，英文翻译为 The Least Knowledge Principle。

```
Each unit should have only limited knowledge about other units: only units
“closely” related to the current unit. Or: Each unit should only talk to its
friends; Don’t talk to strangers.
```

1. 不该有直接依赖关系的类之间，不要有依赖。
2. 有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的有限知识）。
3. 基于最小接口而非最大实现编程，依赖的接口越多，那么当接口的实现有变动时，就需要执行更多的测试工作量。

迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

## 高内聚、松耦合

如何理解高内聚、低耦合？

- “高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。

- 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

## 如何提高代码复用性

- 减少代码耦合

  - 对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。

- 满足单一职责原则

  - 我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。

- 模块化

  - 这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。

- 业务与非业务逻辑分离

  - 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。

- 通用代码下沉

  - 从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。

- 继承、多态、抽象、封装

  - 在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。

- 应用模板等设计模式

  - 一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。


除了上面的这些方法之外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

相比于代码的可复用性，DRY 原则适用性更强一些。我们可以不写可复用的代码，但一定不能写重复的代码。

# 业务系统分析与设计

要有能力独立负责一个系统，能端到端开发一个完整的系统，这其中的工作就包括，前期的需求沟通分析，中期的代码设计实现，后期的系统上线维护等。

大多数软件开发项目背后的想法其实就是要把一个手工的过程自动化，或者换句话说就是要创建一种新的自动化方式来做一些对于手工操作而言过于困难的事情。

这里有一个核心概念：

- **在自动化一个过程之前，你必须知道手动完成这件事情的全过程。**

软件开发的过程往往都是从对问题的透彻理解开始的。也就是说，你要自动化些什么？

## 需求分析

通过一些工具收集需求，罗列用户用例。

## 系统设计

面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块）两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。

### 合理地将功能划分到不同模块

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

### 模块间的交互关系

常见的系统之间的交互关系有两种：

- 一种是同步接口调用
- 另一种是利用消息中间件异步调用

第一种方式简单直接，第二种方式的解耦效果更好。上下层系统之间的调用倾向于通过 同步接口，同层之间的调用倾向于异步消息调用。

## 模块的接口、数据库、业务模型

业务系统本身的设计无外乎有这样三方面的工作要做：

- 接口设计
- 数据库设计
- 业务模型设计（也就是业务逻辑）

### 数据库

主要设计事务表（每次操作时产生的数据）的内容，一些总体的信息可以通过统计计算这些表的内容来得到。

### 接口设计

接口设计要符合单一职责原则，粒度越小通用性就越好。但是接口粒度太小也会带来一些问题，一个功能的实现需要调用多个小接口

- 如果接口走网络，多次调用会影响性能
- 本该在一个接口中完成的原子操作，现在拆分成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，另一个接口执行失败了）

所以为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，在封装一层粗粒度的接口给外部使用。

### 业务模型

从代码实现的角度来说，大部分业务系统的开发都可以分为 controller、service、repository 三层。

- controller 层负责接口暴露
- repository 层负责数据读写
- service 层负责核心业务逻辑，也就是这里的业务模型

## 为什么需要 MVC 三层开发

- 分层能起到代码复用的作用
  - 同一个 repository 可能会被多个 service 调用
  - 同一个 service 可能会被多个 controller 调用
  - 如果没有 service 层，每个 controller 可能需要实现同样的逻辑，违背 DRY 原则
- 分层能起到隔离变化的作用
  - 分层体现了抽象和封装的设计思想。比如 repo 实现了对数据库访问的操作，提供了抽象的数据访问接口。
  - 基于接口而非实现编程的设计思想，service 层使用 repo 层提供的接口，并不关心底层依赖的是那种具体的数据库，便于替换数据库。
  - controller service repository 三层的稳定程度不同，分层之后，controller 层的变化不会影响到稳定的的 repository 层。
- 分层能起到隔离关注点的作用
  - repository 层只关注数据的读写
  - service 层只关注业务逻辑，不关心数据来源
  - controller 层只关注与外界打交道，数据校验、封装、格式转换，不关心业务
  - 三层之间的关注点不同，分层之后，职责分明，更加符合单一原则，代码的内聚性更好
- 分层能提高代码的可测试性
  - 下层的代码通过依赖注入的方式供上层使用
  - 可以用 mock 的数据来替代真实数据
- 分层能应对系统的复杂性
  - 当一个类或者一个函数的代码过多之后，可读性、可维护性就会变差，那就要想办法拆分，拆分分为垂直和水平两个方向：
    - 水平方向基于业务来做拆分，就是模块化
    - 竖直方向基于流程来做拆分，就是这里说的分层
  - 不管是分层、模块化，还是 OOP、DDD、以及各种设计模式，原则和思想，都是为了应对复杂系统，应对系统的复杂性，对于简单系统是发挥不了作用的。

## 设计模型与思想

![image-20240314114017391](figures/image-20240314114017391.png)

# 通用框架分析与设计

## 需求分析

### 功能性需求分析

### 非功能性需求分析

## 框架设计

基于最小原型的思想，先聚集一个简单的场景，基于此设计实现一个简单的原型。

- 根据上面的功能性需求分析，选择一个简单的应用场景
- 实现最简小原型时可以不考虑各种复杂的软件设计要求，先实现一个最简单的功能，把功能先写到一个类中就可以了，有了基础原型，后续才可以慢慢迭代
- 实现一个最简单的原型后，可以帮我们理顺思路，基于这个最小圆形，可以开始进行框架设计，画出系统设计图，让我们的脑子释放一部分资源去思考更细节的内容

对于复杂框架的设计，一开始的时候会觉得无从下手。这里有几个小技巧，包括：

- 画产品线框图
- 聚焦简单应用场景
- 设计实现最小原型
- 画系同设计图等

这些方法的目的都是为了让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。

## 代码实现

前面我们已经对框架进行了需求分析和粗略的模块划分，后面我们就可以利用面向对象设计、实现方法，并结合之前学过的设计思想、设计原则来考虑如何编写灵活、可扩展、高质量的代码实现。

实际上，优秀的代码都是重构出来的，复杂的代码都是慢慢堆砌出来的。那些优秀而复杂的开源代码和项目代码，也都是靠几年时间慢慢迭代优化出来的，罗马不是一天建成的。

迭代思维很重要，不要刚开始就追求完美。

面相对象设计和实现要做的事情，就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽可能地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等各种设计原则和思想，尽可能做到代码客服用、易读、易扩展、易维护。



