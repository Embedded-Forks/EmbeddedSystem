# 设计模式

## 创建型模式

### 单例模式

单例模式理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫做单例设计模式，简称单例模式。

从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如系统配置信息类，除此之外我们还可以使用单例解决资源访问冲突的问题。

单例模式的问题：

- 单例对 OOP 特性的支持不友好
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数

### 工厂模式

工厂方法和抽象工厂。

工厂模式分为简单工厂、工厂方法和抽象工厂。简单工厂和工厂方法原理比较简单，在实际的项目中也比较常用。

### 建造者模式

### 原型模式（不常用）

## 结构型模式

### 代理模式

- 代理模式的原理与实现

在不改变原始类（或者叫被代理类的情况下），通过引入代理类来给原始类增加附加功能。一般情况下我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。


C 语言实现：

```c
#include <stdio.h>

// 定义一个接口的结构体，包含一个函数指针
typedef struct {
    void (*performTask)(void);
} ITask;

// 实现结构体，这里模拟一个具体的任务
void RealTask() {
    printf("Performing the real task.\n");
}

// 代理结构体，包含一个ITask类型的指针，指向真实的任务
typedef struct {
    ITask* realTask;
} ProxyTask;

// 代理方法，调用真实任务的方法
void ProxyPerformTask(ProxyTask* proxy) {
    printf("Proxy: Calling the real task.\n");
    proxy->realTask->performTask();
}

int main() {
    // 创建真实任务和代理任务的实例
    ITask realTask = {RealTask};
    ProxyTask proxy = {&realTask};

    // 通过代理执行任务
    ProxyPerformTask(&proxy);

    return 0;
}
```

在这个例子中：

- ITask 结构体定义了一个可以执行任务的接口，这里是一个函数指针 performTask。

- RealTask 是一个具体的任务函数，执行实际的操作。

- ProxyTask 结构体充当代理，持有一个指向 ITask 的指针。

- ProxyPerformTask 函数通过代理调用实际的任务。

这种方式允许在调用实际任务之前或之后添加额外的逻辑，例如权限检查、日志记录等，从而实现代理模式的核心目的.

- 动态代理的原理与实现

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模版模式的重复代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

C 语言实现：

在 C 语言中实现动态代理比较复杂，因为 C 语言本身不支持面向对象编程的许多特性，如反射或动态绑定，这些通常是实现动态代理所需的。不过，我们可以通过一些技巧模拟出动态代理的效果，主要是利用函数指针和一些运行时决策逻辑。

以下简单的示例，展示如何在 C 语言中模拟动态代理的基本思想：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义一个任务接口，使用函数指针
typedef void (*TaskFunction)(void);

// 真实任务
void RealTask() {
    printf("Executing the real task.\n");
}

// 代理执行前的额外操作
void BeforeTask() {
    printf("Before the task: Security check or logging.\n");
}

// 代理执行后的额外操作
void AfterTask() {
    printf("After the task: Cleanup or logging.\n");
}

// 动态代理的执行函数
void DynamicProxy(TaskFunction realTask) {
    BeforeTask();  // 前置操作
    realTask();    // 执行真实任务
    AfterTask();   // 后置操作
}

int main() {
    // 使用动态代理执行真实任务
    DynamicProxy(RealTask);
    return 0;
}
```

在这个例子中：

- TaskFunction 是一个函数指针类型，用于指向具体的任务函数。

- RealTask 是实际的任务函数。

- BeforeTask 和 AfterTask 是在任务执行前后要进行的额外操作。

- DynamicProxy 函数接受一个 TaskFunction 类型的函数指针，实现了在执行真实任务前后插入额外操作的逻辑。

这种方式虽然不是传统意义上的动态代理（因为它不涉及到运行时的方法查找或自动方法调用），但它通过在运行时决定哪个函数被调用，以及在调用前后执行哪些附加操作，从而模拟了动态代理的某些行为。这种方法在 C 语言的限制下是一种可行的解决方案。

- 实践思考

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还还可以用在 RPS、缓存等应用场景中。

可以考虑给系统的 profiler 接口做一个代理，以避免 profiler 功能支持直接修改业务代码。

### 桥接模式

桥接模式有两种不同的理解方式：

- 将抽象和实现解耦，让他们可以独立变化
- 一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

C 语言实现：

桥接模式使用聚合关系，在抽象类对象中通过指针的方式引用另一个对象，另一个对象表示某一个维度，引用多个其他对象，则可以表示多个不同维度。还可以通过 set 的方式替换不同的对象引用，以实现通过多个不同维度对象来生成抽象类对象。

- 实践思考

如果一个系统可以通过多个角度进行分类，每一种分类都有可能变化，那么就将各个角度分离出来让他们独立变化，减少这些角度之间的耦合。

当我们需要多角度来分类对象的时候，如果只用继承会造成大量的类的增加，而且需要做很多改动，不满足开闭原则，此时可以考虑使用桥接模式。

### 装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。他的主要作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

装饰器模式是一种结构型设计模式，用于动态地给一个对象添加一些额外的职责或功能。它提供了一种灵活的替代方案来扩展功能，而不是通过继承来实现。在装饰器模式中，组件和装饰器都遵循同一个接口，装饰器持有组件的一个引用，并在调用组件功能前后可以执行额外的行为。

核心概念：

1. 组件接口：定义了对象的接口，装饰器和具体的对象都要实现这个接口。
2. 具体组件：实现或继承组件接口的功能，提供基本功能。
3. 装饰器基类：实现具体接口的同时持有一个组件接口的引用，这个引用指向一个具体的组件或另一个装饰器。
4. 具体装饰器：扩展装饰器基类，在调用组件的功能前后添加额外的行为。

C 语言实现：

在这个例子中，我们定义了一个组件接口 Component，它包含一个函数指针 operation。`concreteOperation` 是具体组件的实现。Decorator 结构体扩展了 Component 并包含了一个指向另一个 Component 的指针，这样它就可以装饰其他组件。`enhancedOperation` 在调用原始组件的操作前后添加了额外的行为，实现了装饰的功能。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义组件接口
typedef struct Component {
    void (*operation)(struct Component* self);
} Component;

// 具体组件实现
void concreteOperation(Component* self) {
    printf("Concrete Component Operation\n");
}

Component* createConcreteComponent() {
    Component* comp = (Component*)malloc(sizeof(Component));
    comp->operation = concreteOperation;
    return comp;
}

// 装饰器基类
typedef struct {
    Component component;
    Component* wrappedComponent;
} Decorator;

void baseDecoratorOperation(Component* self) {
    Decorator* decorator = (Decorator*)self;
    decorator->wrappedComponent->operation(decorator->wrappedComponent);
}

Decorator* createDecorator(Component* wrapped) {
    Decorator* decorator = (Decorator*)malloc(sizeof(Decorator));
    decorator->component.operation = baseDecoratorOperation;
    decorator->wrappedComponent = wrapped;
    return decorator;
}

// 具体装饰器实现
void enhancedOperation(Component* self) {
    printf("Before Enhanced Operation\n");
    baseDecoratorOperation(self);
    printf("After Enhanced Operation\n");
}

Decorator* createEnhancedDecorator(Component* wrapped) {
    Decorator* decorator = createDecorator(wrapped);
    decorator->component.operation = enhancedOperation;
    return decorator;
}

int main() {
    Component* simple = createConcreteComponent();
    Decorator* decorated = createEnhancedDecorator(simple);

    decorated->component.operation((Component*)decorated);

    free(decorated);
    free(simple);

    return 0;
}
```

下面的例子展示了多层装饰的实现（即嵌套使用多个装饰器），可以通过创建多个装饰器实例，并将一个装饰器的输出作为另一个装饰器的输入来实现。每个装饰器都包装了前一个装饰器，从而形成一个装饰链。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义组件接口
typedef struct Component {
    void (*operation)(struct Component* self);
} Component;

// 具体组件实现
void concreteOperation(Component* self) {
    printf("Concrete Component Operation\n");
}

Component* createConcreteComponent() {
    Component* comp = (Component*)malloc(sizeof(Component));
    comp->operation = concreteOperation;
    return comp;
}

// 装饰器基类
typedef struct {
    Component component;
    Component* wrappedComponent;
} Decorator;

void baseDecoratorOperation(Component* self) {
    Decorator* decorator = (Decorator*)self;
    decorator->wrappedComponent->operation(decorator->wrappedComponent);
}

Decorator* createDecorator(Component* wrapped) {
    Decorator* decorator = (Decorator*)malloc(sizeof(Decorator));
    decorator->component.operation = baseDecoratorOperation;
    decorator->wrappedComponent = wrapped;
    return decorator;
}

// 具体装饰器实现
void enhancedOperation(Component* self) {
    printf("Before Enhanced Operation\n");
    baseDecoratorOperation(self);
    printf("After Enhanced Operation\n");
}

Decorator* createEnhancedDecorator(Component* wrapped) {
    Decorator* decorator = createDecorator(wrapped);
    decorator->component.operation = enhancedOperation;
    return decorator;
}

int main() {
    Component* simple = createConcreteComponent();
    Decorator* firstDecorator = createEnhancedDecorator(simple);
    Decorator* secondDecorator = createEnhancedDecorator((Component*)firstDecorator);

    secondDecorator->component.operation((Component*)secondDecorator);

    free(secondDecorator);
    free(firstDecorator);
    free(simple);

    return 0;
}
```

在这个例子中，main 函数中首先创建了一个基本的组件 simple。然后，我们创建了第一个装饰器 `firstDecorator`，它包装了 simple。接着，我们创建了第二个装饰器 `secondDecorator`，它包装了 `firstDecorator`。当调用 `secondDecorator` 的 operation 方法时，它会首先执行 `secondDecorator` 的增强操作，然后调用 `firstDecorator` 的增强操作，最后执行基本组件 simple 的操作。

这种方式允许你灵活地添加多个装饰器，每个装饰器都可以添加额外的行为，而不影响其他装饰器的功能。这样的设计使得功能的扩展变得非常灵活和强大。

### 适配器模式

适配器模式的英文翻译是 Adapter Design Pattern。这个模式是用来做适配的，他将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。

适配器模式是用来做适配，他将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式有两种实现方式：类适配器和对象适配器。其中类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

适配器模式可以作为一种补偿模式，用来补救设计上的缺陷。下面这些接口不兼容的场景可以考虑使用适配器模式：

1. 封装有缺陷的接口设计
2. 统一多个类的接口设计
3. 替换依赖的外部系统
4. 兼容老版本接口
5. 适配不同格式的数据

### 门面模式（不常用）

### 组合模式（不常用）

### 享元模式（不常用）

## 行为型模式

### 观察者模式

在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。一般情况下，被依赖的对象叫做被观察者（observable），依赖的对象叫做观察者（Observer）。

设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将大块代码拆分成职责更单一的小类，使其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。

观察者模式的应用场景非常广泛，小道代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅，RSS feeds，本质上都是观察者模式。不同应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式。有进程内的实现方式，也有跨进程的实现方式。

### 模板模式

#### 模版方法

模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的算法，我们可以理解为广义上的业务逻辑，并不特指数据结构和算法中的算法。这里的算法骨架就是模版，包含算法骨架的方法就是模板方法，这也是模版方法模式名字的由来。

在模版模式经典的实现中，模版方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模版模式的实现比较灵活，以上两点都不是必须的。

模版模式有两大作用，复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模版方法的代码。扩展指的是，框架通过模版模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

#### 回调

回调，它跟模板模式具有相同的作用：代码复用和扩展。在一些框架、类库、组件等的设计中经常会用到。

相对于普通的的函数调用，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。

回调可以细分为同步回调和异步回调。从应用场景来看，同步回调看起来更像是模板模式，异步回调看起来更像是观察者模式。回调跟模版模式的区别，更多的是在代码实现上，而非应用场景上。

回调基于组合关系来实现，模版模式基于继承关系来实现，回调比模板模式更加灵活。

#### 模板 VS 回调

从应用场景上来看，同步回调跟模版模式几乎一致。他们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而回调跟模板模式有较大差别，更像是观察者模式。

从代码实现上来看，回调和模板模式完全不同。

- 回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；
- 模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。

我们认为组合优于继承，这里也不例外。在代码实现上，回调相对于模版模式会更加灵活，主要体现在下面几点：

1. 像 java 这种语言只支持单继承，基于模版模式编写的子类，已经继承了一个父类，不再具有继承的能力。
2. 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模版模式针对不同的实现都要定义不同的子类。
3. 如果某个类中定义了多个模版方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模版方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要向用到的模版方法中注入回调对象即可。



