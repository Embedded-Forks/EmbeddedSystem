# 设计模式

## 创建型模式

### 单例模式

单例模式理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫做单例设计模式，简称单例模式。

从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如系统配置信息类，除此之外我们还可以使用单例解决资源访问冲突的问题。

单例模式的问题：

- 单例对 OOP 特性的支持不友好
- 单例会隐藏类之间的依赖关系
- 单例对代码的扩展性不友好
- 单例对代码的可测试性不友好
- 单例不支持有参数的构造函数

### 工厂模式

工厂模式分为简单工厂、工厂方法和抽象工厂。简单工厂和工厂方法原理比较简单，在实际的项目中也比较常用。

### 建造者模式

### 原型模式

## 结构型模式

### 代理模式

#### 代理模式的原理与实现

在不改变原始类（或者叫被代理类的情况下），通过引入代理类来给原始类增加附加功能。一般情况下我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。


##### C 语言实现

```c
#include <stdio.h>

// 定义一个接口的结构体，包含一个函数指针
typedef struct {
    void (*performTask)(void);
} ITask;

// 实现结构体，这里模拟一个具体的任务
void RealTask() {
    printf("Performing the real task.\n");
}

// 代理结构体，包含一个ITask类型的指针，指向真实的任务
typedef struct {
    ITask* realTask;
} ProxyTask;

// 代理方法，调用真实任务的方法
void ProxyPerformTask(ProxyTask* proxy) {
    printf("Proxy: Calling the real task.\n");
    proxy->realTask->performTask();
}

int main() {
    // 创建真实任务和代理任务的实例
    ITask realTask = {RealTask};
    ProxyTask proxy = {&realTask};

    // 通过代理执行任务
    ProxyPerformTask(&proxy);

    return 0;
}
```

在这个例子中：

- ITask 结构体定义了一个可以执行任务的接口，这里是一个函数指针 performTask。

- RealTask 是一个具体的任务函数，执行实际的操作。

- ProxyTask 结构体充当代理，持有一个指向 ITask 的指针。

- ProxyPerformTask 函数通过代理调用实际的任务。

这种方式允许在调用实际任务之前或之后添加额外的逻辑，例如权限检查、日志记录等，从而实现代理模式的核心目的.

#### 动态代理的原理与实现

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模版模式的重复代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

##### C 语言实现

在 C 语言中实现动态代理比较复杂，因为 C 语言本身不支持面向对象编程的许多特性，如反射或动态绑定，这些通常是实现动态代理所需的。不过，我们可以通过一些技巧模拟出动态代理的效果，主要是利用函数指针和一些运行时决策逻辑。

以下简单的示例，展示如何在 C 语言中模拟动态代理的基本思想：

```c
#include <stdio.h>
#include <stdlib.h>

// 定义一个任务接口，使用函数指针
typedef void (*TaskFunction)(void);

// 真实任务
void RealTask() {
    printf("Executing the real task.\n");
}

// 代理执行前的额外操作
void BeforeTask() {
    printf("Before the task: Security check or logging.\n");
}

// 代理执行后的额外操作
void AfterTask() {
    printf("After the task: Cleanup or logging.\n");
}

// 动态代理的执行函数
void DynamicProxy(TaskFunction realTask) {
    BeforeTask();  // 前置操作
    realTask();    // 执行真实任务
    AfterTask();   // 后置操作
}

int main() {
    // 使用动态代理执行真实任务
    DynamicProxy(RealTask);
    return 0;
}
```

在这个例子中：

- TaskFunction 是一个函数指针类型，用于指向具体的任务函数。

- RealTask 是实际的任务函数。

- BeforeTask 和 AfterTask 是在任务执行前后要进行的额外操作。

- DynamicProxy 函数接受一个 TaskFunction 类型的函数指针，实现了在执行真实任务前后插入额外操作的逻辑。

这种方式虽然不是传统意义上的动态代理（因为它不涉及到运行时的方法查找或自动方法调用），但它通过在运行时决定哪个函数被调用，以及在调用前后执行哪些附加操作，从而模拟了动态代理的某些行为。这种方法在 C 语言的限制下是一种可行的解决方案。

#### 代理模式的应用场景

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还还可以用在 RPS、缓存等应用场景中。

#### 实践思考

可以考虑给系统的 profiler 接口做一个代理，以避免 profiler 功能支持直接修改业务代码。

### 桥接模式

桥接模式有两种不同的理解方式：

- 将抽象和实现解耦，让他们可以独立变化
- 一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

#### C 语言实现

桥接模式使用聚合关系，在抽象类对象中通过指针的方式引用另一个对象，另一个对象表示某一个维度，引用多个其他对象，则可以表示多个不同维度。还可以通过 set 的方式替换不同的对象引用，以实现通过多个不同维度对象来生成抽象类对象。

#### 实践思考

如果一个系统可以通过多个角度进行分类，每一种分类都有可能变化，那么就将各个角度分离出来让他们独立变化，减少这些角度之间的耦合。

当我们需要多角度来分类对象的时候，如果只用继承会造成大量的类的增加，而且需要做很多改动，不满足开闭原则，此时可以考虑使用桥接模式。

### 装饰器模式

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代集成。他的主要作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要依据。除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

装饰器模式是一种结构型设计模式，用于动态地给一个对象添加一些额外的职责或功能。它提供了一种灵活的替代方案来扩展功能，而不是通过继承来实现。在装饰器模式中，组件和装饰器都遵循同一个接口，装饰器持有组件的一个引用，并在调用组件功能前后可以执行额外的行为。

核心概念：

1. 组件接口：定义了对象的接口，装饰器和具体的对象都要实现这个接口。
2. 具体组件：实现或继承组件接口的功能，提供基本功能。
3. 装饰器基类：实现具体接口的同时持有一个组件接口的引用，这个引用指向一个具体的组件或另一个装饰器。
4. 具体装饰器：扩展装饰器基类，在调用组件的功能前后添加额外的行为。

#### C 语言实现

在这个例子中，我们定义了一个组件接口 Component，它包含一个函数指针 operation。concreteOperation 是具体组件的实现。Decorator 结构体扩展了 Component 并包含了一个指向另一个 Component 的指针，这样它就可以装饰其他组件。`enhancedOperation` 在调用原始组件的操作前后添加了额外的行为，实现了装饰的功能。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义组件接口
typedef struct Component {
    void (*operation)(struct Component* self);
} Component;

// 具体组件实现
void concreteOperation(Component* self) {
    printf("Concrete Component Operation\n");
}

Component* createConcreteComponent() {
    Component* comp = (Component*)malloc(sizeof(Component));
    comp->operation = concreteOperation;
    return comp;
}

// 装饰器基类
typedef struct {
    Component component;
    Component* wrappedComponent;
} Decorator;

void baseDecoratorOperation(Component* self) {
    Decorator* decorator = (Decorator*)self;
    decorator->wrappedComponent->operation(decorator->wrappedComponent);
}

Decorator* createDecorator(Component* wrapped) {
    Decorator* decorator = (Decorator*)malloc(sizeof(Decorator));
    decorator->component.operation = baseDecoratorOperation;
    decorator->wrappedComponent = wrapped;
    return decorator;
}

// 具体装饰器实现
void enhancedOperation(Component* self) {
    printf("Before Enhanced Operation\n");
    baseDecoratorOperation(self);
    printf("After Enhanced Operation\n");
}

Decorator* createEnhancedDecorator(Component* wrapped) {
    Decorator* decorator = createDecorator(wrapped);
    decorator->component.operation = enhancedOperation;
    return decorator;
}

int main() {
    Component* simple = createConcreteComponent();
    Decorator* decorated = createEnhancedDecorator(simple);

    decorated->component.operation((Component*)decorated);

    free(decorated);
    free(simple);

    return 0;
}
```

下面的例子展示了多层装饰的实现（即嵌套使用多个装饰器），可以通过创建多个装饰器实例，并将一个装饰器的输出作为另一个装饰器的输入来实现。每个装饰器都包装了前一个装饰器，从而形成一个装饰链。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义组件接口
typedef struct Component {
    void (*operation)(struct Component* self);
} Component;

// 具体组件实现
void concreteOperation(Component* self) {
    printf("Concrete Component Operation\n");
}

Component* createConcreteComponent() {
    Component* comp = (Component*)malloc(sizeof(Component));
    comp->operation = concreteOperation;
    return comp;
}

// 装饰器基类
typedef struct {
    Component component;
    Component* wrappedComponent;
} Decorator;

void baseDecoratorOperation(Component* self) {
    Decorator* decorator = (Decorator*)self;
    decorator->wrappedComponent->operation(decorator->wrappedComponent);
}

Decorator* createDecorator(Component* wrapped) {
    Decorator* decorator = (Decorator*)malloc(sizeof(Decorator));
    decorator->component.operation = baseDecoratorOperation;
    decorator->wrappedComponent = wrapped;
    return decorator;
}

// 具体装饰器实现
void enhancedOperation(Component* self) {
    printf("Before Enhanced Operation\n");
    baseDecoratorOperation(self);
    printf("After Enhanced Operation\n");
}

Decorator* createEnhancedDecorator(Component* wrapped) {
    Decorator* decorator = createDecorator(wrapped);
    decorator->component.operation = enhancedOperation;
    return decorator;
}

int main() {
    Component* simple = createConcreteComponent();
    Decorator* firstDecorator = createEnhancedDecorator(simple);
    Decorator* secondDecorator = createEnhancedDecorator((Component*)firstDecorator);

    secondDecorator->component.operation((Component*)secondDecorator);

    free(secondDecorator);
    free(firstDecorator);
    free(simple);

    return 0;
}
```

在这个例子中，main 函数中首先创建了一个基本的组件 simple。然后，我们创建了第一个装饰器 `firstDecorator`，它包装了 simple。接着，我们创建了第二个装饰器 secondDecorator，它包装了 firstDecorator。当调用 `secondDecorator` 的 operation 方法时，它会首先执行 secondDecorator 的增强操作，然后调用 `firstDecorator` 的增强操作，最后执行基本组件 simple 的操作。

这种方式允许你灵活地添加多个装饰器，每个装饰器都可以添加额外的行为，而不影响其他装饰器的功能。这样的设计使得功能的扩展变得非常灵活和强大。

## C 实现技巧

### 聚合关系

在 C 语言中，由于没有内置的面向对象支持，实现聚合关系需要使用结构体和指针。聚合关系是一种特定类型的关联关系，表示拥有或者包含，其中一个对象（容器）包含或拥有另一个对象（成员），**但两者的声明周期不必完全相同，即成员对象可以独立于容器对象存在**。

实现步骤：

1. 定义结构体：定义代表不同对象的结构体，每个结构体代表一个类在面向对象语言中的角色。
2. 使用指针表示聚合：在一个结构体中使用指向另一个结构体的指针来表示聚合关系。这个指针代表一个对象包含另一个对象。
3. 管理生命周期：确保在适当的时候创建和销毁成员对象。由于 C 语言不自动管理内存，需要手动管理对象的创建和销毁。

实例代码，我们有一个 car 结构体，它聚合了一个 engine 结构体，Car 拥有 engine，但 engine 的声明周期可以独立于 car。

在这个例子中，car 结构体通过一个指向 engine 的指针来聚合 engine。这表明 car 对象拥有一个 Engine 对象，但是 engine 的创建和销毁是独立管理的，符合聚合关系的定义。这种方式允许 engine 在 car 被销毁后继续存在，或者在 car 创建之前就已经存在。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义 Engine 结构体
typedef struct {
    int horsepower;
} Engine;

// 定义 Car 结构体，它聚合了 Engine
typedef struct {
    Engine* engine;
} Car;

// 创建一个 Engine 对象
Engine* createEngine(int horsepower) {
    Engine* newEngine = (Engine*)malloc(sizeof(Engine));
    if (newEngine) {
        newEngine->horsepower = horsepower;
    }
    return newEngine;
}

// 创建一个 Car 对象，并聚合一个 Engine
Car* createCar(Engine* engine) {
    Car* newCar = (Car*)malloc(sizeof(Car));
    if (newCar) {
        newCar->engine = engine;
    }
    return newCar;
}

// 清理 Car 对象
void destroyCar(Car* car) {
    // 注意：这里不销毁 engine，因为它的生命周期可以独立于 car
    free(car);
}

// 清理 Engine 对象
void destroyEngine(Engine* engine) {
    free(engine);
}

int main() {
    Engine* engine = createEngine(300);
    Car* car = createCar(engine);

    printf("Car with engine horsepower: %d\n", car->engine->horsepower);

    destroyCar(car);
    destroyEngine(engine);

    return 0;
}
```



