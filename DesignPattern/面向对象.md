# 面向对象

## 基础概念

- 什么是面向对象编程？
  - 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。
  - 类将数据（存储为属性）和在数据上执行操作的全过程（称为操作）组合到一起，因为它们往往是内在紧密结合的。对象是类的实例，这相当于结构化语言中的变量，但是它功能更强大，因为对象提供属性的值和操纵他们的操作。
- 什么是面向对象语言？
  - 面向对象编程语言是支持类或对象的语法机制，并**有现成的语法机制**，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
- 如何判定一个编程语言是否是面向对象编程语言？
  - 如果按照严格的定义，需要有现成的语法支持类、对象、四大特性才能叫做面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

- 面向对象编程和面向对象编程语言之间有何关系?
  - 面向对象编程一般使用面向对象语言来进行，但是不用面向对象编程语言，我们仍然可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

- 什么是面向对象分析和面向对象设计？
  - 简单讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

## 四大特性

理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。

## 类交互关系

UML 中定义了六种类之间的关系，他们分别为泛化、实现、聚合、组合、关联和依赖。

### 泛化

泛化可以简单理解为继承关系，java 实现：

```java
public class A{... }
public class B extends A{ ... }
```

 泛化关系是面向对象中的继承关系。在C语言中，我们可以通过结构体嵌套来模拟：

```c
typedef struct {
    char *name;
} Animal;

typedef struct {
    Animal animal;
    char *dogSpecificAttribute;
} Dog;

void dogBark(Dog *dog) {
    printf("%s barks.\n", dog->animal.name);
}
```

### 实现

实现（Realization）一般是指接口和实现类之间的关系，java 实现：

```java
public interface A {...}
public class B implements A { ... }
```

实现关系通常指一个类实现接口类的方法，在 C 语言中，可以通过结构体和函数指针来模拟接口的实现：

```c
typedef struct {
    void (*eat)(char *);
} AnimalBehavior;

typedef struct {
    AnimalBehavior behavior;
} Animal;

void dogEat(char *food) {
    printf("Dog eats %s.\n", food);
}

Animal createDog() {
    Animal dog;
    dog.behavior.eat = dogEat;
    return dog;
}
```

### 聚合

聚合是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程和学生之间的关系，java 实现：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
```

聚合关系是一种特殊的关联关系，表示整体和部分的关系，但部分可以离开整体而单独存在，C 语言实现：

```c
typedef struct {
    char *name;
} Wheel;

typedef struct {
    Wheel *wheels[4];
} Car;

void assembleCar(Car *car, Wheel *wheels[]) {
    for (int i = 0; i < 4; i++) {
        car->wheels[i] = wheels[i];
    }
}
```

### 组合

组合也是一种包含关系，A 类对象包含 B 类对象，B 类对象的声明周期依赖 A 对象的生命周期，B 对象不可单独存在，比如鸟与翅膀之间的关系，java 实现：

```java
public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
```

组合也是整体和部分的关系，但部分不能离开整体而单独存在，C 语言实现：

```c
typedef struct {
    char *name;
} Engine;

typedef struct {
    Engine engine;  // 引擎是车的一部分，不能单独存在
} Car;

void createCar(Car *car, char *engineName) {
    car->engine.name = engineName;
}
```

### 关联

关联是一种非常弱的关系，包含聚合、组合两种关系，具体到代码层面，如果 B 类对象是 A 类对象的成员变量，那 B 类对象和 A 类对象就是关联关系，java 实现：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
或者
public class A {
  private B b;
  public A() {
    this.b = new B();
  }

```

关联关系表示不同类的对象之间的链接，它使一个对象可以知道另一个对象的属性和方法。这种关系是两个或多个对象间的协作或交互，关联可以是单向的或双向的。关联关系通常在类的属性中体现，即一个类会持有另一个类的引用作为其属性。在下面的例子中，Teacher 是  Student 的成员变量，那么 Teacher 类和 Student 类就是关联关系，C 语言实现：

```c
typedef struct {
    char *name;
} Teacher;

typedef struct {
    char *name;
    Teacher *teacher;  // 学生知道他的老师是谁
} Student;

void assignTeacher(Student *student, Teacher *teacher) {
    student->teacher = teacher;
}
```


### 依赖

依赖是一种比关联关系更加弱的关系，包含关联关系。不管 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称他们有依赖关系，java 实现：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
或者
public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
或者
public class A {
  public void func(B b) { ... }
}

```

依赖关系是一种使用关系，其中一个类的实现依赖于另一个类的定义。在这个例子中，`writeExam` 函数依赖于 Pen 类，因为它使用了 Pen 类的对象作为参数。依赖关系仅仅是方法界别的使用或调用，一个对象在执行操作时需要另一个对象的帮助，C 语言实现：

```c
typedef struct {
    char *name;
} Pen;

void writeExam(char *name, Pen *pen) {
    printf("%s is writing the exam with %s pen.\n", name, pen->name);
}
```

### 实践思考


最近开发中刚好遇到了一个实际场景非常适合采用聚合关系来设计。用户申请了句柄对象（即容器对象），然后在后续初始化过程中，这个句柄对象引用了一个成员对象，而这个成员对象还可能被其他线程异步的释放，导致其生命周期于句柄对象不一致。

如果句柄对象和成员对象被设计成组合关系（即生命周期相同），那么成员对象被销毁时，也导致句柄对象被销毁。而此时外部还有人持有句柄对象，此时再通过句柄对象访问成员对象则会造成系统出错。

如何设计句柄对象和成员对象之间为聚合关系就解决了这个问题，成员对象被销毁时，可以在句柄对象上置标志位，当其他主体想要通过句柄来访问成员对象时，检查标志位，就知道成员对象是否可用。

- 简单理解的话也可以只保留四种关系，泛化、实现、组合、依赖。其中泛化、实现、依赖的定义不变，组合关系替代 UML 中的组合、聚合、关联三个概念，之所以这样命名，是为了跟我们的**多用组合少用继承设计**原则中的组合统一含义。

# 面向对象开发

## 面向对象分析（OOA）

先从最简单的方案想起，然后再优化。把整个分析的过程分为 4 轮，每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具体化，最终产生清晰的、可落地的需求定义。

需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以一定不要只关心设计与实现，前期的需求分析同等重要。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

## 面向对象设计（OOD）

面相对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。

面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。

在面相对象设计环节，我们将需求描述转化为具体的类的设计，我们把这一设计环节拆解细化一下，主要包含一下几个部分：

- 划分职责进而识别出有哪些类

  - 根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

- 定义类及其属性和方法

  - 我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

- 定义类与类之间的交互关系

  - UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

- 将类组装起来并提供执行入口

  - 我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来，完成整个工作流程。

## 面向对象编程（OOP）

面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。

## 实践思考

即使我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML 图，也不可能把每个细节、交互都想的很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。

毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。

