# 面向对象开发

## 面向对象分析（OOA）

先从最简单的方案想起，然后再优化。把整个分析的过程分为 4 轮，每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具体化，最终产生清晰的、可落地的需求定义。

需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以一定不要只关心设计与实现，前期的需求分析同等重要。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

## 面向对象设计（OOD）

面相对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。

面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。

在面相对象设计环节，我们将需求描述转化为具体的类的设计，我们把这一设计环节拆解细化一下，主要包含一下几个部分：

- 划分职责进而识别出有哪些类

  - 根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

- 定义类及其属性和方法

  - 我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

- 定义类与类之间的交互关系

  - UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

- 将类组装起来并提供执行入口

  - 我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来，完成整个工作流程。

## 面向对象编程（OOP）

面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。

## 辩证思考与灵活应用

即使我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML 图，也不可能把每个细节、交互都想的很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。

毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。

# 面向对象设计基础

类将数据（存储为属性）和在数据上执行操作的全过程（称为操作）组合到一起，因为它们往往是内在紧密结合的。对象是类的实例，这相当于结构化语言中的变量，但是它功能更强大，因为对象提供属性的值和操纵他们的操作。

后面记录面向对象编程的重要方面，以及如何使用 C 来实现这些概念。

## 聚合关系

在 C 语言中，由于没有内置的面向对象支持，实现聚合关系需要使用结构体和指针。聚合关系是一种特定类型的关联关系，表示拥有或者包含，其中一个对象（容器）包含或拥有另一个对象（成员），**但两者的生命周期不必完全相同，即成员对象可以独立于容器对象存在**。

实现步骤：

1. 定义结构体：定义代表不同对象的结构体，每个结构体代表一个类在面向对象语言中的角色。
2. 使用指针表示聚合：在一个结构体中使用指向另一个结构体的指针来表示聚合关系。这个指针代表一个对象包含另一个对象。
3. 管理生命周期：确保在适当的时候创建和销毁成员对象。由于 C 语言不自动管理内存，需要手动管理对象的创建和销毁。

实例代码，我们有一个 car 结构体，它聚合了一个 engine 结构体，Car 拥有 engine，但 engine 的声明周期可以独立于 car。

在这个例子中，car 结构体通过一个指向 engine 的指针来聚合 engine。这表明 car 对象拥有一个 Engine 对象，但是 engine 的创建和销毁是独立管理的，符合聚合关系的定义。这种方式允许 engine 在 car 被销毁后继续存在，或者在 car 创建之前就已经存在。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义 Engine 结构体
typedef struct {
    int horsepower;
} Engine;

// 定义 Car 结构体，它聚合了 Engine
typedef struct {
    Engine* engine;
} Car;

// 创建一个 Engine 对象
Engine* createEngine(int horsepower) {
    Engine* newEngine = (Engine*)malloc(sizeof(Engine));
    if (newEngine) {
        newEngine->horsepower = horsepower;
    }
    return newEngine;
}

// 创建一个 Car 对象，并聚合一个 Engine
Car* createCar(Engine* engine) {
    Car* newCar = (Car*)malloc(sizeof(Car));
    if (newCar) {
        newCar->engine = engine;
    }
    return newCar;
}

// 清理 Car 对象
void destroyCar(Car* car) {
    // 注意：这里不销毁 engine，因为它的生命周期可以独立于 car
    free(car);
}

// 清理 Engine 对象
void destroyEngine(Engine* engine) {
    free(engine);
}

int main() {
    Engine* engine = createEngine(300);
    Car* car = createCar(engine);

    printf("Car with engine horsepower: %d\n", car->engine->horsepower);

    destroyCar(car);
    destroyEngine(engine);

    return 0;
}
```

## 实践思考

最近开发中刚好遇到了一个实际场景非常适合采用聚合关系来设计。

用户申请了句柄对象（即容器对象），然后在后续初始化过程中，这个句柄对象引用了一个成员对象，而这个成员对象还可能被其他线程异步的释放，导致其生命周期于句柄对象不一致。

如果句柄对象和成员对象被设计成组合关系（即生命周期相同），那么成员对象被销毁时，也导致句柄对象被销毁。而此时外部还有人持有句柄对象，此时再通过句柄对象访问成员对象则会造成系统出错。

如果使用聚合关系来做这两个对象的设计就解决这个问题，成员对象被销毁时，可以在句柄对象上置标志位，当其他主体想要通过句柄来访问成员对象时，检查标志位，就知道成员对象是否可用。