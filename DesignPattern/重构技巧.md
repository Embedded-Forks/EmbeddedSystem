# 代码重构

## 理论基础

- 重构的目的：为什么重构（why）?

  - 对于项目来言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。

- 重构的对象：重构什么（what）？

  - 按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。
  - 小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。
- 重构的时机：什么时候重构（when）？
  - 我们一定要建立持续重构的意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。

- 重构的方法：如何重构（how）?
  - 大规模高层次的重构难度比较大，需要组织。有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以只要你愿意且有时间，随时随地都可以去做。
  - 在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。
  - 大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时都可以去做。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具，来自动发现代码中的问题，然后针对性地进行重构优化。

尽管我们说重构能力很重要，但持续重构意识更重要。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。

**而那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。**

## 代码的可测性

- **什么是代码的可测试性？**
- 粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。
- **编写可测试性代码的最有效手段**
  - 依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。
  - 依赖注入之所以能提高代码可测试性，主要是因为通过这样的方式我们能轻松地用 mock 对象替换依赖的真实对象。那么我们为什么要 mock 这个对象呢？这是因为，这个对象参与逻辑执行，但又不可控（比如我们要依赖它输出的数据做后续的计算）。
  - 我们可以应用依赖注入，将所依赖对象的创建反转给上层逻辑，在外部创建好之后，再注入到需要测试的类中。
    - 通过依赖注入，我们就可以使用 mock 类来替换依赖类，这样就可以，利用 mock 类来解依赖
    - 可以在类中添加一个成员变量及其 set 方法，这样就可以很容易在外部替换这个成员变量，这个成员变量可能是一个外部实现。
    - 我们通过依赖注入和 mock，让单元测试代码不依赖任何不可控的外部服务。
  - 对于 logger 对象来说，我们只需要往里写入数据，并不读取数据，不参与业务逻辑的执行，不会影响代码逻辑的正确性。对于这种对象，就没必要进行 mock。
  - 此外，一些只是为了存储数值的对象，比如 string、map、`UseVo`，也没必要通过依赖注入的方式来创建，直接在类中通过 new 创建就行了。
- **常见的 Anti-Patterns**

  - 常见的测试不友好的代码有下面这 5 种：
    - 代码中包含未决行为逻辑
    - 滥用可变全局变量
    - 滥用静态方法
    - 使用复杂的继承关系
    - 高度耦合的代码

# 小型重构：编码规范

## 关于命名

- 命名的关键是能准确达意，对于不同作用域的命名，我们可以适当地选择不同的长度。
- 我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
- 命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。命名要符合项目的统一规范，也不要用一些反直觉的命名。
- 接口有两种命名方式：
  - 一种是在接口中带前缀 "I"
  - 另一种实在接口的实现类中带后缀 "impl"
- 对于抽象类的命名也有两种方式：
  - 一种是带上前缀 Abstract
  - 一种是不带前缀
  - 两种命名方式都可以，关键是要在项目中统一

## 关于注释

注释的内容包含三个方面：做什么，为什么，怎么做、对于一些复杂的类和接口，我们可能还需要写明如何用。

类和函数一定要写注释，而且要写得尽可能全面详细。函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结注释来提高代码可读性。

## 关于代码风格

- 函数、类多大才合适？
  - 函数的代码行数不要超过一屏幕的大小，比如 50 行。类的大小限制比较难确定。
- 一行代码多长最合适？
  - 最好不要超过 IDE 的显示宽度。当然也不能太小，否则会导致很多稍微长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。
- 善用空行分割单元块。对于比较长的函数，为了让逻辑更加清晰，可以使用空行来分割各个代码块。
- 四格缩进还是两格缩进？我个人比较推荐使用两格缩进，这样可以节省空间，尤其是在代码嵌套层次比较深的情况下。不管是用两格缩进还是四格缩进，一定不要用 tab 键缩进。
- 大括号是否要另起一行？将大括号放到跟上一条语句同一行，可以节省代码行数。但是将大括号另起新的一行的方式，左右括号可以垂直对齐，哪些代码属于哪一个代码块，更加一目了然。
- 类中成员怎么排列？在 Google 编程规范中，依赖类按照字母序从小到大排列。类中先写成员变量后写函数。成员变量之间或函数之间，先写静态成员变量或函数，后写普通变量或函数，并且按照作用域大小依次排列。

## 编码技巧

- 将复杂的逻辑提炼拆分成函数和类（降低代码复杂度）
- 通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况
- 函数中不要使用参数来做代码执行逻辑的控制
- 函数设计要职责单一
- 移除过深的嵌套层次，方法包括：
  - 去掉多余的 if 或 else 语句
  - 使用 continue、break、return 关键字提前退出嵌套
  - 调整执行顺序来减少嵌套
  - 将部分嵌套逻辑抽象成函数
- 用字面常量取代魔法数
- 用解释性变量来解释复杂表达式，以提高代码可读性

## 防御性编程

防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，那怕是由其他子程序的产生的错误数据。

“垃圾进，垃圾出”显然不符合程序安全的标准，一般有三种方法处理进来的“垃圾”。

- **检查来源于外部的所有数据的值**：当从文件、用户、网络或其他外部接口获取数据时，检查数据以确保在允许的范围内。比如：整数溢出、字符串超长、SQL注入、HTML\XML注入等等问题。
- **检查子程序所有输入参数的值**：与检查来源于外部的数据本质是一样的，只不过数据来源于其他子程序。
- **决定如何处理错误的输入数据**：一旦检测到无效的入参，选择合适的处理策略。

# 大型重构：解耦

软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。控制代码复杂性最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。

## 是否需要解耦

- 看修改代码会不会牵一发而动全身
- 根据模块与模块之间、类与类之间的依赖关系图，根据依赖关系图的复杂性做判断

## 如何解耦

### 封装与抽象

### 中间层

### 模块化

### 其他设计思想与原则

- 单一职责原则
- 基于接口而非实现编程
- 依赖注入
- 多用组合少用继承
- 迪米特法则
- 解耦设计模式

# 质量评判标准

代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一维度去评价一段代码的好坏。

最常用到几个评判代码质量的标准有：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，**可维护性、可读性、可扩展性**又是提到最多的、最重要的三个评价标准。

## Review check list

- 代码结构是否合理?
- 代码是否容易理解？
- 业务是否正确?
- 异常考虑是否全面？
- 是否有隐藏的 bug?
- 线程是否安全？
- 性能是否满足业务需求？
- 是否符合编码规范？

[Google review 最佳实践](https://jimmysong.io/eng-practices/docs/review/reviewer/standard/)，在进行代码审查时，您应该确保：

- 代码设计精良。
- 该功能对代码用户是有好处的。
- 任何 UI 变更都是合理的且看起来是好的。
- 其中任何并行编程都是安全的。
- 代码并不比它需要的复杂。
- 开发人员没有实现他们将来**可能**需要，但不知道他们现在是否需要的东西。
- 代码有适当的单元测试。
- 测试精心设计。
- 开发人员使用了清晰的名称。
- 注释清晰有用，且大多用来解释**为什么**而不是**做什么**。
- 代码有适当记录成文件（通常在 g3doc 中）。
- 代码符合我们的风格指南。

确保查看您被要求查看的**每一行**代码，查看**上下文**，确保您**提高代码健康状况**，并赞扬开发人员所做的**好事**。

## 常规 check list

- 目录设置是否合理、模块划分是否清晰、代码结构是否满足高内聚低耦合？
- 是否遵循经典的设计原则和设计思想（SOLID DRY KISS YAGIN LOD 等）？
- 设计模式是否应用得当？是否有过度设计？
- 代码是否容易扩展？如果要添加新功能，是否容易实现？
- 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
- 代码是否容易测试？单元测试是否全面覆盖各种正常和异常的情况？
- 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

## 业务需求 check list

- 代码是否实现了预期的业务需求？
- 逻辑是否正确？是否处理了各种异常情况？
- 日志打印是否得当？是否方便 debug 排查问题？
- 接口是否易用？是否支持幂等、事务等？
- 代码是否存在并发问题？是否线程安全？
- 性能是否有优化空间，比如，SQL、算法是否可以优化？
- 是否有安全漏洞？比如输入输出校验是否全面？

## 异常处理

平时进行软件设计开发的时候，我们除了要保证正常情况下的逻辑运行正确之外，还需要编写大量额外的代码，来处理有可能出现的异常情况，以保证代码在任何情况下，都在我们的掌控之内，不会出现非预期的运行结果。

程序的 bug 往往都出现在一些边界条件和异常情况下，所以说异常处理得好坏直接影响了代码的健壮性。全面、合理地处理各种异常能有效减少代码 bug，也是保证代码质量的一个重要手段。

再简单的代码，看上去再完美的代码，只要我们下功夫去推敲，总有可以优化的空间，就看你愿不愿意把事情做到极致。

# 制定重构计划

在进行系统设计和实现的时候，我们要循序渐进、小步快跑。重构代码的过程也应该遵循这样的思路。每次改动一点点，改好之后，再进行下一轮的优化，保证每次对代码的改动不会过大，能在很短的时间内完成。我们可以将代码质量问题分成多次重构来完成，例如：

## 第一轮：提高代码的可读性

## 第二轮：提高代码的可测试性

- 将需要测试的代码和不可控组件（例如本机名，随机函数，时间函数）进行隔离

## 第三轮：编写完善的单元测试

## 第四轮：重构完成之后添加注释

- 主要讲注释添加到类和函数上

# 感悟

我应该认识到，需要使用一种逐步改善的视角来看待代码质量，不要妄想可以一次性给出完美的设计或实现：

- 要分阶段完成代码的基础功能开发和持续重构，每次只做很小的改动，循序渐进，小步快跑。

- 在代码重构时，应当坚持执行多轮的代码修改，而不是一次改好，以避免每次改动过大，这一点很重要。

- 通过重构，我们可以将代码结构变得更加合理、清晰、有逻辑性。
